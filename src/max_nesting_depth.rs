use clippy_utils::diagnostics::span_lint;
use rustc_hir::intravisit::{FnKind, Visitor, walk_body, walk_expr};
use rustc_hir::{Body, ClosureKind, CoroutineKind, CoroutineSource, Expr, ExprKind, FnDecl};
use rustc_lint::{LateContext, LateLintPass};
use rustc_span::Span;
use rustc_span::def_id::LocalDefId;

const MAX_DEPTH: usize = 4;

dylint_linting::declare_late_lint! {
    /// ### What it does
    ///
    /// Checks that control flow nesting depth does not exceed 4.
    ///
    /// ### Why is this bad?
    ///
    /// Deeply nested code is harder to read, understand, and maintain.
    ///
    /// ### Known problems
    ///
    /// None.
    ///
    /// ### Example
    ///
    /// ```rust
    /// for _a in 0..3 {
    ///     for _b in 0..3 {
    ///         for _c in 0..3 {
    ///             for _d in 0..3 {
    ///                 for _e in 0..3 { // depth 5, exceeds maximum of 4
    ///                 }
    ///             }
    ///         }
    ///     }
    /// }
    /// ```
    pub MAX_NESTING_DEPTH,
    Warn,
    "nesting depth exceeds the maximum of 4"
}

impl<'tcx> LateLintPass<'tcx> for MaxNestingDepth {
    fn check_fn(
        &mut self,
        cx: &LateContext<'tcx>,
        fn_kind: FnKind<'tcx>,
        _decl: &'tcx FnDecl<'tcx>,
        body: &'tcx Body<'tcx>,
        _span: Span,
        _id: LocalDefId,
    ) {
        // Skip closures; they are visited as part of the enclosing function body.
        if matches!(fn_kind, FnKind::Closure) {
            return;
        }
        let mut visitor = NestingVisitor { cx, depth: 0 };
        walk_body(&mut visitor, body);
    }
}

struct NestingVisitor<'a, 'tcx> {
    cx: &'a LateContext<'tcx>,
    depth: usize,
}

impl<'a, 'tcx> NestingVisitor<'a, 'tcx> {
    /// Increment depth and emit a lint if the limit is exceeded.
    /// Returns `true` if the caller should recurse into children.
    fn try_enter(&mut self, expr: &'tcx Expr<'tcx>) -> bool {
        self.depth += 1;
        if self.depth > MAX_DEPTH {
            span_lint(
                self.cx,
                MAX_NESTING_DEPTH,
                expr.span,
                format!(
                    "nesting depth is {}, which exceeds the maximum of {MAX_DEPTH}",
                    self.depth
                ),
            );
            self.depth -= 1;
            false
        } else {
            true
        }
    }

    /// Walk an `if / else if / else` chain, treating the whole chain as a
    /// single nesting level (already incremented by the caller).
    fn walk_if_chain(&mut self, mut expr: &'tcx Expr<'tcx>) {
        loop {
            if let ExprKind::If(cond, then_block, else_opt) = expr.kind {
                self.visit_expr(cond);
                self.visit_expr(then_block);
                match else_opt {
                    // `else if`: same chain, same depth â€“ loop without incrementing.
                    Some(else_expr)
                        if matches!(else_expr.kind, ExprKind::If(..))
                            && !else_expr.span.from_expansion() =>
                    {
                        expr = else_expr;
                    }
                    // Plain `else` block.
                    Some(else_expr) => {
                        self.visit_expr(else_expr);
                        break;
                    }
                    None => break,
                }
            } else {
                break;
            }
        }
    }
}

impl<'a, 'tcx> Visitor<'tcx> for NestingVisitor<'a, 'tcx> {
    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {
        match &expr.kind {
            ExprKind::If(..) => {
                // Skip `if` expressions generated by compiler desugaring, e.g. the
                // synthetic condition check inside a `while` loop.
                if expr.span.from_expansion() {
                    walk_expr(self, expr);
                    return;
                }
                if self.try_enter(expr) {
                    self.walk_if_chain(expr);
                    self.depth -= 1;
                }
            }
            ExprKind::Match(..) => {
                // Skip `match` expressions from desugaring, e.g. the iterator
                // `match` produced by a `for` loop.
                if expr.span.from_expansion() {
                    walk_expr(self, expr);
                    return;
                }
                if self.try_enter(expr) {
                    walk_expr(self, expr);
                    self.depth -= 1;
                }
            }
            ExprKind::Loop(..) => {
                // Count all loops (`for`, `while`, `loop`).
                // `for` loops desugar to a `Loop` with a desugaring span, so we
                // intentionally do NOT skip based on `from_expansion()` here.
                if self.try_enter(expr) {
                    walk_expr(self, expr);
                    self.depth -= 1;
                }
            }
            ExprKind::Closure(closure) => {
                // The body of an `async fn` is wrapped in a synthetic coroutine
                // closure (CoroutineSource::Fn).  Recurse into it to check the
                // user-written body without counting the wrapper as nesting.
                if matches!(
                    closure.kind,
                    ClosureKind::Coroutine(CoroutineKind::Desugared(_, CoroutineSource::Fn))
                ) {
                    let inner_body = self.cx.tcx.hir_body(closure.body);
                    walk_body(self, inner_body);
                    return;
                }
                // Skip closures from macro expansion.
                if expr.span.from_expansion() {
                    let inner_body = self.cx.tcx.hir_body(closure.body);
                    walk_body(self, inner_body);
                    return;
                }
                // User-written closures count as one nesting level.
                if self.try_enter(expr) {
                    let inner_body = self.cx.tcx.hir_body(closure.body);
                    walk_body(self, inner_body);
                    self.depth -= 1;
                }
            }
            _ => walk_expr(self, expr),
        }
    }
}
